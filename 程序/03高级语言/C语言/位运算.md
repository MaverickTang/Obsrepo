

# bit，byte之间的转换

1byte=8bit

1个int=4byte=32bit

1个short=2byte，一个long=8byte，一个char=2bytes

byte的最高位为符号位，剩余7位为数值位，符号位为0表示正数，1为负数；

## 原码，反码，补码

原码：将一个数值以二进制的形式展示；

反码：正数的反码就是它的原码，负数的反码就是原码的符号位不变，数值位取反；

补码：正数的补码就是它的原码，负数的补码就是反码的符号位不变，数值位加1；

计算机在存储一个数字时并不是直接存储该数字对应的二进制数字，而是存储该数字对应二进制数字的补码

| 数值             | 15       | -15      |
| ---------------- | -------- | -------- |
| 原码             | 00001111 | 1000‭1111‬ |
| 反码             | 00001111 | 11110000 |
| 补码（实际存储） | 00001111 | 11110001 |

- 机器数：一个数在计算机的存储形式是二进制数，我们称这些二进制数为机器数，机器数是有符号，在计算机中用机器数的最高位存放符号位，0表示正数，1表示负数。
- 机器数的真值：因为带有符号位，所以机器数的形式值不等于其真值，以机器数1000 0111为例，其真正表示的值为-7，而形式值为135。**将带符号的机器数的真正表示的值称为机器数的真值。**
- 所以输入数据后：转换为原码，原码转反码，反码转补码最后储存

![img](https://pic4.zhimg.com/80/v2-7507f422286e51a39cd4a873e76c1d97_1440w.webp)

### 使用补码运算

1 - 1 = 1 + (-1)

= 原：[ 0000 0001 ] + 原：[ 1000 0001 ]

= 补：[ 0000 0001 ] + 补：[ 1111 1111 ]

= 补： [ 0000 0000 ] = 原： [ 0000 0000 ] = 0

这样0用[0000 0000]表示，而以前出现问题的-0则不存在了，而且人们还发现可以用[1000 0000]表示-128。

**-128的推算过程如下**：

(-1) + (-127) = -128

= 原：[1000 0001] + 原：[ 1111 1111 ]

= 补：[ 1111 1111 ] + 补：[ 1000 0001 ]

= 补：[ 1000 0000 ]

**注意**：因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示，只要补码是[1000 0000]，其十进制数值就为-128。

计算机中一个8位的二进制数的存储范围是用补码表示的[-128,127]

# C中的进制数

## 二进制数、八进制数和十六进制数的表示

二进制：0b或0B开头

八进制：必须以0开头

十六进制：必须以0x或0X开头

```c
int a = 0b101;  //换算成十进制为 5
int c = 0177777;  //换算成十进制为 65535
int c = 0xffff;  //换算成十进制为 65535
int c= 0xffffffff;//换算成十进制为 -1
```

## 0xffffffff

8个f，换算成二进制是1111 1111 1111 .。。（8组1111），如果是unsigned int（最高位不是符号位），则为4294967295（最大的int），如果是signed，则为-1

## 输出

|          | short        | int        | long         |
| -------- | ------------ | ---------- | ------------ |
| 八进制   | %ho          | %o         | %lo          |
| 十进制   | %hd          | %d         | %ld          |
| 十六进制 | %hx 或者 %hX | %x 或者 %X | %lx 或者 %lX |



# 位运算（&、|、^、~、>>、<<）

## 逻辑运算符与二进制运算符区别

1.&是一个[位运算符](https://www.baidu.com/s?wd=位运算符&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，&&是一个[逻辑运算符](https://so.csdn.net/so/search?q=逻辑运算符&spm=1001.2101.3001.7020)

2，&是将两个[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)的数逐位相与，结果是相与之后的结果，&&就是判断两个表达式的真假性，只有两个表达式同时为真才为真，有一个为假则为假。

3.&除了是一个[位运算符](https://www.baidu.com/s?wd=位运算符&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，也是取地址符，&&就是一个单纯的逻辑运算符，没有任何其他含义。

## 位运算概述

从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。

口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码：

int a = 35;
int b = 47;
int c = a + b;

计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：

35:  0 0 1 0 0 0 1 1
47:  0 0 1 0 1 1 1 1
————————————————————
82:  0 1 0 1 0 0 1 0

所以，相比在代码中直接使用(+、-、*、/)运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。

## 位运算概览

### 按位与运算符（&）#

**定义**：参加运算的两个数据，按二进制位进行"与"运算。
两位同时为1，结果才为1，否则结果为0。
**与运算的用途：**
1）**清零**
如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。
2）**取一个数的指定位**
比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位。
3）**判断奇偶**
只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。

### 按位或运算符（|）

定义：参加运算的两个对象，按二进制位进行"或"运算。
参加运算的两个对象只要有一个为1，其值为1。
例如：3|5即 0000 0011| 0000 0101 = 0000 0111，因此，3|5的值得7。　
注意：负数按补码形式参加按位或运算。
或运算的用途：
1）常用来对一个数据的**某些位设置为1**
比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。

### 异或XOR运算符（^）

定义：参加运算的两个数据，按二进制位进行"异或"运算。
参加运算的两个对象，如果两个相应位**相同为0，相异为1**

异或的几条性质:

-   1、交换律
-   2、结合律 (a^b)^c == a^(b^c)
-   3、对于任何数x，都有 x^x=0，x^0=x
-   4、自反性: a^b^b=a^0=a;

异或运算的用途：
1）**翻转指定位**
比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。
2）**与0相异或值不变**
例如：1010 1110 ^ 0000 0000 = 1010 1110
3）**交换两个数**
实例
void Swap(int &a, int &b){  
    if (a != b){  
        a ^= b;  
        b ^= a;  
        a ^= b;  
    }  
}  

### 取反运算符 (~)

定义：参加运算的一个数据，按二进制进行"取反"运算。
运算规则：　
对一个二进制数按位取反，即将0变1，1变0。
取反运算的用途：
**1）使一个数的最低位为零**
使a的最低位为0，可以表示为：a & ~1。~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为" ~"运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

### 左移运算符（<<）

定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。
设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。
若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。

### 右移运算符（>>）

定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。
例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。
操作数每右移一位，相当于该数除以2。

### 复合赋值运算符

位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：

&=        例：a&=b    相当于     a=a&b

|=        例：a|=b    相当于     a=a|b

’>>‘=      例：a>>=b   相当于     a=a>>b

<<=      例：a<<=b     相当于      a=a<<b

^=        例：a^=b    相当于   a=a^b

运算规则：和前面讲的复合赋值运算符的运算规则相似。

不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。

以"与运算"为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行"与运算"，右端对齐后，左边不足的位依下面三种情况补足，

-   1）如果整型数据为正数，左边补16个0。
-   2）如果整型数据为负数，左边补16个1。
-   3）如果整形数据为无符号数，左边也补16个0。
    如：long a=123；int b=1；计算a& b。

如：long a=123；int b=-1；计算a& b。

如：long a=123；unsigned intb=1；计算a & b。















